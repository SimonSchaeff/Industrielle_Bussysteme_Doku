\chapter*{Umsetzung}
\label{cha:Umsetzung}
Im Folgenden soll die Umsetzung der State Machine als SPS-Prpogramm beschrieben werden. Dabei werden die einzelnen Programmbausteine hierarchisch und beginnend beim Organisationsbaustein (OB1) kurz erläutert.

\subsection*{PLC Main}
\label{subsec:PLC_Main}
Im Organisationsbaustein befinden sich in Summe drei Programmbausteine. Dabei handelt es sich um die Bausteine "DTI515 parametrization", "DTI515 Read/Write Data" und "DTI515 RFID Manager". Die ersten beiden Bausteine müssen mit Werten versorgt werden, um die RFID-Antenne zu betreiben.
Der Block DTI515 parametrization bietet drei Eingänge, die für die Umsetzung relevant sind. Die Eingänge heißen "Mode", "SetValue" und "Execute". Mit dem Eingang Mode kann festgelegt werden, ob gelesen oder geschrieben werden soll. Mit dem Eingang SetValue wird im Schreibfall der Wert, welcher geschrieben wird, übergeben. Mit Execute wird das letztendliche Schreiben oder Lesen getriggert. DTI515 parametrization bietet außerdem insgesamt 6 Ausgänge. Relevant für das Projekt ist nur der Ausgang ‚Error‘, welcher anzeigt, dass ein Fehler aufgetreten ist. Alle Eingänge und Ausgänge sind mit PLC-Variablen verknüpft.
Der Block DTI515 Read/Write Data hat sieben Eingänge. Vier dieser Eingänge sind für die Umsetzung des Projekts relevant. Diese werden durch PLC-Variablen versorgt, welche vom RFID-Manger gesetzt werden. Es handelt sich um die Eingänge ‚Execute‘, ‚Mode‘, ‚Length‘ und ‚WrData‘. Mit Mode wird gewählt, ob gelesen oder geschrieben wird. Über Length wird festgelegt, wie viele Byte im Schreibfall geschrieben werden sollen. WrData ist der Eingang, der mit den zu versendenden Daten versorgt wird. Execute triggert das letztendliche Schreiben von Daten auf den RFID-Tag. Von den sechs Ausgängen dieses Bausteins sind 2 relevant. Zum einen der Ausgang ‚TagPresent‘. Zum anderen der Ausgang ‚Error‘. Mittels TagPresent kann ermittelt werden. ob sich ein RFID-Tag in der Nähe der Antenne befindet. Error wird überprüft, um festzustellen, ob das Schreiben fehlerfrei verlaufen ist. Der Wert beider wird in einer PLC-Variable abgelegt (siehe Abb. \ref{fig:Main[OB1]Netzwerk1}, \ref{fig:Main[OB1]Netzwerk2}, \ref{fig:Main[OB1]Netzwerk3}, \ref{fig:DTI515ReadWriteData[FC2]Netzwerk1}, \ref{fig:DTI515parametrization[FC3]Netzwerk1}).

\subsection*{RFID-Manager}
\label{subsec:RFID-Manager}
\textbf{Netzwerk 1: Error\_State\_Handling}\\
Dieses Netzwerk hat den Zweck der Bestimmung des Wertes zweier Merker und einer lokalen Variable. Dies geschieht auf Grundlage der von DTI515 parametrization und DTI515 Read/Write Data erzeugten Error Outputs. Diese werden an den DTI515 RFID Manager übergeben. Haben beide Errors den Wert null, wird der Merker ‚M1\_Error\_State Handling‘ mittels SR-Glied rückgesetzt. Andernfalls ist dieser Merker dauerhaft eins. Dessen Ausgang entspricht dem Set Eingang eines SR-Glieds, welches den Merker ‚M2\_Error\_State\_Handling\_Clock‘ setzt. Falls M1\_Error\_State Handling null ist, sind auch der Merker M2\_Error\_State\_Handling\_Clock und die lokale Variable ‚Red\_Led\_Error\_State‘ null. Ist dieser eins, wechseln Merker und Variable in einer Frequenz von 1Hz zwischen High und Low (siehe Abb. \ref{fig:FBRFIDManager[FB3]Netzwerk1}).

\textbf{Netzwerk 2: Tag\_Detected\_Handling}\\
ZZweck des zweiten Netzwerks ist die Bestimmung der Werte für die Merker ‚M3\_Tag\_Detected\_Handling‘ und ‚M4\_Tag\_Detected\_Handling\_Clock‘. Außerdem werden zwei Ausgänge von DTI515 RFID Manager gesetzt, falls ein Tag erkannt wird. Zusätzlich wird die lokale Variable ‚Green\_Led\_Tag\_Detected\_Handling‘ aktualisiert. Falls kein Fehler in Netzwerk 1 detektiert wurde und zusätzlich der Block DTI515 Read/Write Data einen Tag registriert,  wird M3\_Tag\_Detected\_Handling mittels RS-Glied gesetzt. Dessen Ausgang triggert zwei Move-Blöcke, welche die Ausgänge ‚Data\_Length‘ und ‚Data\_Mode‘ aktualisieren. Data\_Length wird auf den Wert 32 Bits (4 Byte) gesetzt. Data\_Mode bekommt den Wert 5, was ‚Schreiben‘ entspricht. Diese Ausgänge konfigurieren die RFID-Antenne. Der Setz-Eingang des SR-Glieds von M4\_Tag\_Detected\_Handling wird über die Move-Blöcke ebenfalls mit dem Ausgang des SR-Gliedes von M3\_Tag\_Detected\_Handling verbunden. Wird dieser Eingang auf eins gesetzt, wechselt der Merker M4\_Tag\_Detected\_Handling\_Clock und die mit dem Ausgang des zugehörigen Flipflops verbundene Variable Green\_Led\_Tag\_Detected\_Handling mit einer Frequenz von 1Hz zwischen High und Low (siehe Abb. \ref{fig:FBRFIDManager[FB3]Netzwerk2}).

\textbf{Netzwerk 3: Save\_System\_Time}\\
Es soll möglich sein die aktuelle Systemzeit auf den NFC-Tag zu schreiben. Zu diesem Zweck muss es möglich sein diese zu generieren. Dies geschieht in Netzwerk 3. Gesetzt wird der Merker ‚M5\_Save\_System\_Time‘ und eine lokale Variable. Dabei handelt es sich um die Variable ‚Systemtimeconv‘. Falls der Merker M3\_Tag\_detected\_Handling in Netzwerk 2 gesetzt wurde und zusätzlich ‚Green\_button‘ den Wert eins hat, wird mittels eines ‚Time\_TCK‘ Blocks die aktuelle Systemzeit ermittelt und in der lokalen Variable ‚Systemtime‘ abgespeichert. Der Wert in Systemtime muss anschließend noch in einen Integer gewandelt werden. Das geschieht im Anschluss an den Time\_TCK Block im Block ‚T\_CONV‘, welcher Systemtimeconv als Ausgang hat. Abschießend wird M5\_Save\_System\_Time mittels eines SR-Glieds einmalig gesetzt. Ein Rücksetzten dessen ist nicht vorgesehen. Es hat den Zweck sicherzustellen, dass mindestens einmal die aktuelle Systemzeit ermittelt und in Systemtimeconv abgelegt wurde (siehe Abb. \ref{fig:FBRFIDManager[FB3]Netzwerk3}).

\textbf{Netzwerk 4 und 5: Write\_Tag\_Handling und Delete\_Tag\_Handling}\\
Die beiden Netzwerke sind für das letztendliche Beschreiben und Löschen des NFC-Tags vorgesehen. Deren Aufbau ist identisch, weshalb diese hier zusammengefasst werden. Sie unterscheiden sich lediglich darin, von welche Variablen und Inputs sie gesteuert werden und welche Variablen und Merker sie definieren. In beiden Fällen wird zunächst mal ein Merker definiert. In Netzwerk 4 ist das ‚M6\_Write\_Tag\_Handling‘. In Netzwerk 5 handelt es sich um ‚M7\_Delete\_Tag\_Handling‘. Beide sind mit einem SR-Glied verbunden. Beim Schreiben wird M6\_Write\_Tag\_Handling gesetzt, falls der Eingangsparameter Green\_Button, der Merker M3\_Tag\_Detected\_Handling aus Netzwerk 2 und der Merker M5\_Save\_System\_Time aus Netzwerk 3 den Wert True haben. Rückgesetzt wird, falls Merker M3\_Tag\_Detected\_Handling aus Netzwerk 2 den Wert False hat oder ein Fehler in Netzwerk 1 detektiert und in M1\_Error\_State\_Handling abgelegt wurde. Beim Löschen wird M7\_Delete\_Tag\_Handling gesetzt, falls der Eingang Red\_button und der Merker M3\_Tag\_Detected\_Handling aus Netzwerk 2 wahr sind. Rückgesetzt wird dieser genauso wie M6\_Write\_Tag\_Handling beim Schreiben. Der Ausgang der beiden Merker dient im jeweiligen Netzwerk der Definition eines Ausgangs von DTI515 RFID Manager. Es handelt sich um den Ausgang Data\_Write, welcher ein Array ausgibt. An den Ausgang des zu den Merkern gehörenden Flipflops ist in Netzwerk 4 und 5 eine Kette von vier Move-Blöcken angeschlossen. Diese haben den Zweck das Array von Data\_Write mit Werten zu befüllen. Beim ersten Block wird Adresse 0 beschrieben, beim zweiten Adresse 1, beim dritten Adresse 2 und beim letzten Adresse 3. In Netzwerk 4 (Schreiben) werden die Move-Blöcke mit der zuvor in der Variable Systemtimeconv abgelegten aktuellen Systemzeit befüllt, sodass diese sich anschließen im Array von Data\_Write befindet. In Netzwerk 5 (Löschen) werden die Move-Blöcke mit nullen versorgt und das Array von Data\_Write enthält anschließend nur nullen. Die Werte innerhalb des Arrays werden später auf den NFC-Tag geschrieben. Sobald die Befüllung dessen abgeschlossen ist, wird beim Schreiben in Netzwerk 4 die lokale Variable Execute\_Write\_Handling und Green\_LED\_Write\_Tag\_Handling gesetzt. Beim Löschen in Netzwerk 5 wird die Variable Execute\_Delete\_Handling, Red\_LED\_Delete\_Tag\_Handling und Green\_LED\_Delete\_Tag\_Handling gesetzt  (siehe Abb. \ref{fig:FBRFIDManager[FB3]Netzwerk4}, \ref{fig:FBRFIDManager[FB3]Netzwerk5}).

\textbf{Netzwerk 6: LED\_Control}\\
Netzwerk 6 dient der Steuerung der LED-Anzeigen für die verschiedenen Betriebszustände, basierend auf dem Status der relevanten Merker. Wenn einer der grünen Merker, wie Green\_LED\_Tag\_Detected\_Handling, Green\_LED\_Write\_Tag\_Handling oder Green\_LED\_Delete\_Tag\_Handling, aktiv ist  und kein Fehlerzustand vorliegt (M1\_Error\_State\_Handling ist null), wird der Merker Green\_Button\_LED\_State gesetzt. Dies aktiviert die grüne LED, um anzuzeigen, dass der entsprechende Betriebsmodus erfolgreich erkannt wurde.
Für die rote LED gilt ein ähnliches Prinzip. Wenn der Merker Red\_LED\_Delete\_Tag\_Handling aktiv ist und kein Fehlerzustand vorliegt (M1\_Error\_State\_Handling ist null), wird Red\_Button\_LED\_State gesetzt, sobald Red\_LED\_Error\_State aktiv ist . Dadurch wird die rote LED eingeschaltet, um einen spezifischen Fehlerzustand anzuzeigen. Dies bietet eine visuelle Rückmeldung im Falle eines Problems (siehe Abb. \ref{fig:FBRFIDManager[FB3]Netzwerk6}).

\textbf{Netzwerk 7: Execution\_Operations}\\
Netzwerk 7 ermöglicht die Durchführung von Schreib- oder Löschoperationen auf dem RFID-Tag. Wenn entweder der Merker Execute\_Write\_Handling oder Execute\_Delete\_Handling aktiv ist , wird der Ausgang Execute gesetzt. Dieser Ausgang triggert die eigentliche Aktion, entweder das Schreiben oder Löschen der Daten auf dem RFID-Tag. Dadurch wird sichergestellt, dass die gewünschte Operation korrekt ausgeführt wird und der Prozess ordnungsgemäß abgeschlossen ist (siehe Abb. \ref{fig:FBRFIDManager[FB3]Netzwerk7}).
%---------------------------------------------------------------------------------------
%... Text Umsetzung: Beschreibung der Umsetzung und eigener Untersuchungen ...